# -*- coding: utf-8 -*-"""Created on Wed Feb 19 14:59:57 2020Refer to the instructions on Canvas for more information."I have neither given nor received help on this assignment."author: Phillip McDonough"""from string import ascii_lowercasedef createTable(phrase):    '''    This function creates a 5x5 ciphertable of 25 unique characters     from a passphrase.         Input:   string:         a passphrase    Output:  list of lists:  a ciphertable    '''    phrase = phrase.lower()    alphabet = ascii_lowercase.replace('q', '')    phrase = removeSpacesAndQ(phrase)    phrase = removeDupes(phrase)    noMatches = removeMatches(alphabet, phrase)    phrase += noMatches    ciphertable = [[i for i in phrase[:5]], [i for i in phrase[5:10]],                    [i for i in phrase[10:15]], [i for i in phrase[15:20]],                     [i for i in phrase[20:25]]]        return ciphertabledef removeSpacesAndQ(phrase):    '''    This function removes spaces, punctuation, and the letter    q from an input string.        Input:   string    Output:  updated string with spaces, punctuation, and the letter             q removed (string)    '''    unique = ''    for char in phrase:        if char in ascii_lowercase:            if char != 'q':                unique += char    return unique        def removeDupes(phrase):    '''    This function removes duplicate characters from an input string.        Input:   string    Output:  updated string with the duplicate characters removed (string)    '''    unique = ''    for char in phrase:        if char not in unique:            unique += char    return uniquedef removeMatches(alphabet, phrase):    '''     This function removes characters that exist in a second string from    the first.        Input:   first and second strings    Output:  updated first string with all characters from the second string             removed (string)    '''    unique = ''    for char in alphabet:        if char not in phrase:            unique += char    return uniquedef splitString(plaintext):    '''    This function splits a string into a list of two-character pairs.        Input:   string:  plaintext to be encrypted    Output:  list:    collection of plaintext bigrams    '''    bigrams = []    plaintext = plaintext.lower()    plaintext = removeSpacesAndQ(plaintext)        if len(plaintext) % 2 == 1:        plaintext += 'x'            length = len(plaintext)        for i in range(0, length, 2):        bigrams.append(plaintext[i:i+2])        return bigrams        def playfairRuleOne(pair):    '''    This function takes in a bigram and makes sure it doesn't contain two    of the same character.        Input:   string:  plaintext bigram    Output:  string:  potentially modified bigram    '''    if pair[0] == pair[1]:        if pair[0] == 'x':            pair = 'xz'        else:            pair = pair[0] + 'x'           return pair def decryptRuleOne(pair):    if pair[0] != pair[1]:        if pair == 'xz':            pair = 'xx'        else:            pair = 2 * pair[0]        return pair                         def playfairRuleTwo(pair, table):    '''    This function takes in a bigram and if both letters are in the same row    in the ciphertable, it changes them to be the letters to their immediate     right respectively.            Input:   string:         potentially modified bigram    Input:   list of lists:  ciphertable    Output:  string:         potentially modified bigram    '''    newPair = ''    for row in table:        if pair[0] in row and pair[1] in row:            if row.index(pair[1]) == (len(row)-1):                zeroIndex = row.index(pair[0]) + 1                newPair = row[zeroIndex] + row[0]            elif row.index(pair[0]) == (len(row)-1):                oneIndex = row.index(pair[1]) + 1                newPair = row[oneIndex] + row[1]            else:                zeroIndex = row.index(pair[0]) + 1                oneIndex = row.index(pair[1]) + 1                newPair = row[zeroIndex] + row[oneIndex]            if newPair == '':        return pair    else:        return newPairdef decryptRuleTwo(pair, table):    newPair = ''    for row in table:        if pair[0] in row and pair[1] in row:            if row.index(pair[0]) == row[0]:                oneIndex = row.index(pair[1]) - 1                newPair = row[len(row)-1] + row[oneIndex]            elif row.index(pair[1]) == row[0]:                zeroIndex = row.index(pair[0]) - 1                 newPair = row[zeroIndex] + row[len(row)-1]            else:                zeroIndex = row.index(pair[0]) - 1                oneIndex = row.index(pair[1]) - 1                newPair = row[zeroIndex] + row[oneIndex]        if newPair == '':        return pair    else:        return newPairdef playfairRuleThree(pair, table):           '''    This function takes in a bigram and if both letters are in the same column    in the ciphertable, it changes them to be the letters immediately below     them respectively.        Input:   string:         potentially modified bigram    Input:   list of lists:  ciphertable    Output:  string:         potentially modified bigram    '''        transposedTable = []    for i in range(5):        row = list(map(lambda row: row[i], table))        transposedTable.append(row)            return playfairRuleTwo(pair, transposedTable)    def decryptRuleThree(pair, table):    transposedTable = []    for i in range(5):        row = list(map(lambda row: row[i], table))        transposedTable.append(row)       return decryptRuleTwo(pair, transposedTable)        def playfairRuleFour(pair, table):    '''    This function takes in a bigram and if both letters are not on    the same row and not in the same column they switch column positions,    but keep the same row position.        Input:   string:         potentially modified bigram    Input:   list of lists:  ciphertable    Output:  string:         potentially modified bigram    '''    if (playfairRuleTwo(pair, table) != pair or         playfairRuleThree(pair, table) != pair):        return pair        newPair = ''    rowIndexZero = 0    clmIndexZero = 0    rowIndexOne = 0    clmIndexOne = 0        for row in table:        if pair[0] in row:            rowIndexZero = table.index(row)            clmIndexZero = row.index(pair[0])        elif pair[1] in row:            rowIndexOne = table.index(row)             clmIndexOne = row.index(pair[1])            newZero = table[rowIndexZero][clmIndexOne]    newOne = table[rowIndexOne][clmIndexZero]    newPair = newZero + newOne        return newPair    def decryptRuleFour(pair, table):    if (decryptRuleTwo(pair, table) != pair or         decryptRuleThree(pair, table) != pair):        return pair        newPair = ''    rowIndexZero = 0    clmIndexZero = 0    rowIndexOne = 0    clmIndexOne = 0        for row in table:        if pair[0] in row:            rowIndexZero = table.index(row)            clmIndexZero = row.index(pair[0])        elif pair[1] in row:            rowIndexOne = table.index(row)             clmIndexOne = row.index(pair[1])            newZero = table[rowIndexZero][clmIndexOne]    newOne = table[rowIndexOne][clmIndexZero]    newPair = newZero + newOne        return newPair                    def encrypt(pair, table):    '''    This function exists to call the previous four rules on a bigram.        Input:   string:         plaintext bigram    Input:   list of lists:  ciphertable    Output:  string:         ciphertext bigram    '''    pair = playfairRuleOne(pair)    pair = playfairRuleTwo(pair, table)    pair = playfairRuleThree(pair, table)    pair = playfairRuleFour(pair, table)        return pairdef decrypt (pair, table):    pair = decryptRuleFour(pair, table)    pair = decryptRuleThree(pair, table)    pair = decryptRuleTwo(pair, table)    pair = decryptRuleOne(pair)        return pair    def joinPairs(pairsList):    '''    Given a list of many encrypted pairs, this function joins them all into    a final ciphertext string.        Input:   list:    collection of ciphertext bigrams    Output:  string:  ciphertext    '''    x = ''.join(pairsList)    return xdef main():    print('encrypt = 1')    print('decrypt = 2')    option = int(input('Would you like to encrypt or decrypt: '))        if option == 1:        # encryption         passphrase = input('Enter a passphrase: ')        plaintext = input('What do you want to encrypt: ')        passphrase = passphrase.lower()        plaintext = plaintext.lower()        table = createTable(passphrase)        bigramList = splitString(plaintext)        newList = []        for bigram in bigramList:            newList.append(encrypt(bigram,table))                    encryption = joinPairs(newList)        print()        print('Your encryption is: ', encryption)    else:         # decryption        passphrase = input('Enter a passphrase: ')        encryption = input('What do you want to decrypt: ')        print()        passphrase = passphrase.lower()        encryption = encryption.lower()        table = createTable(passphrase)        bigramList = splitString(encryption)        newList = []        for bigram in bigramList:            newList.append(decrypt(bigram, table))                decryption = joinPairs(newList)         print('Your decryption is: ', decryption)                        # # '''    # # Example main() function; can be commented out when running your    # # tests    # # '''    # table = createTable("i am entering a pass phrase")    # splitMessage = splitString("this is a test message")    # pairsList = []    # print(table) # printed for debugging purposes        # for pair in splitMessage:    #     # Note: encrypt() should call the four rules    #     pairsList.append(encrypt(pair, table))    # cipherText = joinPairs(pairsList)            # print(cipherText) #printed as the encrypted output    # #output will be hjntntirnpginprnpm    # testCreateTable()    # testSplitString()    # testRuleOne()    # testRuleTwo()    # testRuleThree()    # testRuleFour()    # testEncrypt()    # testjoinPairs()###############################################################def testCreateTable():    # Testing that createTable() returns the correct table and all its helper    # functions are returning the correct mutations    alphabet = ascii_lowercase.replace('q', '')    assert createTable('i am entering a pass phrase') == [['i', 'a', 'm', 'e', 'n'],     ['t', 'r', 'g', 'p', 's'], ['h', 'b', 'c', 'd', 'f'], ['j', 'k', 'l', 'o', 'u'],     ['v', 'w', 'x', 'y', 'z']], 'createTable() is returning the wrong list of lists'    assert removeSpacesAndQ('i am entering a pass phrase q') == 'iamenteringapassphrase', 'removeSpacesAndQ() is returning a phrase with a space, punctuation, or q'    assert removeDupes('iamenteringapassphrase') == 'iamentrgpsh', 'removeDupes() is returning a string with duplicate characters'    assert removeMatches(alphabet, 'iamentrgpsh') == 'bcdfjklouvwxyz', 'removeMatches() is returning the wrong letters not already included in the passphrase'def testSplitString():    # Testing splitString() splits a string into a list of two-character pairs    assert splitString('this is my plaintext') == ["th", "is", "is", "my", "pl", "ai", "nt", "ex", "tx"], 'splitString() is returning an incorrect list'    assert splitString('this is my plaintex') == ["th", "is", "is", "my", "pl", "ai", "nt", "ex"], 'splitString() is returning an incorrect list'    assert 'q' not in splitString('this is my plaintextq'), 'splitString() is returning a list with a q in it'    assert ' ' not in splitString('this is my plaintext'), 'splitString() is returning a list with a space in it'def testRuleOne():    # Testing playfairRuleOne() correctly handles a bigram with repeated characters    assert playfairRuleOne('xx') == 'xz', 'playfairRuleOne() is handling a repeated x character incorrectly'    assert playfairRuleOne('aa') == 'ax', 'playfairRuleOne() is handling a repeated a character incorrectly'    assert playfairRuleOne('ab') == 'ab', 'playfairRuleOne() is handling the bigram ab incorrectly'    assert playfairRuleOne('xc') == 'xc', 'playfairRuleOne() is handling the bigram xc incorrectly'def testRuleTwo():    # Testing playfairRuleTwo() correctly handles a bigram with characters in the same row    table = createTable("i am entering a pass phrase")    assert playfairRuleTwo('am', table) == 'me', 'playfairRuleTwo() is returning the wrong bigram when given am'    assert playfairRuleTwo('tp', table) == 'rs', 'playfairRuleTwo() is returning the wrong bigram when given tp'    assert playfairRuleTwo('cf', table) == 'dh', 'playfairRuleTwo() is returning the wrong bigram when given cf'    assert playfairRuleTwo('ed', table) == 'ed', 'playfairRuleTwo() is returning the wrong bigram when given ed'def testRuleThree():    # Testing playfairRuleThree() correctly handles a bigram with characters in the same column    table = createTable('i am entering a pass phrase')    assert playfairRuleThree('th', table) == 'hj', 'playfairRuleThree() is returning the wrong bigram when given th'    assert playfairRuleThree('gl', table) == 'cx', 'playfairRuleThree() is returning the wrong bigram when given gl'    assert playfairRuleThree('tv', table) == 'hi', 'playfairRuleThree() is returning the wrong bigram when given tv'    assert playfairRuleThree('ax', table) == 'ax', 'playfairRuleThree() is returning the wrong bigram when given ax'def testRuleFour():    # Testing playfairRuleFour() correctly handles a bigram with characters neither in the same column nor in the same row    table = createTable('i am entering a pass phrase')    assert playfairRuleFour('fm', table) == 'cn', 'playfairRuleFour() is returning the wrong bigram when given fm'    assert playfairRuleFour('as', table) == 'nr', 'playfairRuleFour() is returning the wrong bigram when given as'    assert playfairRuleFour('jw', table) == 'kv', 'playfairRuleFour() is returning the wrong bigram when given jw'    assert playfairRuleFour('do', table) == 'do', 'playfairRuleFour() is returning the wrong bigram when given do'def testEncrypt():    # Testing encrypt() correctly encrypts a bigram    table = createTable('i am entering a pass phrase')    assert encrypt('gg', table) == 'cm', 'encrypt() is returning an incorrect encryption of gg'    assert encrypt('aa', table) == 'mw', 'encrypt() is returning an incorrect encryption of aa'    assert encrypt('xx', table) == 'yv', 'encrypt() is returning an incorrect encryption of xx'    assert encrypt('ab', table) == 'rk', 'encrypt() is returning an incorrect encryption of ab'def testjoinPairs():    # Testing joinPairs() joins the bigrams in a list    assert joinPairs(["th", "is", "is", "my", "pl", "ai", "nt", "ex", "tx"]) == 'thisismyplaintextx', 'joinPairs() is not joining the bigrams correctly'    assert joinPairs(['i', 'a', 'm', 'e', 'n']) == 'iamen', 'joinPairs() is not joining the bigrams correctly'    assert joinPairs(['t', 'r', 'g', 'p', 's']) == 'trgps', 'joinPairs() is not joining the bigrams correctly'    assert joinPairs(['no', 'dr', 'in', 'ks', '!']) == 'nodrinks!', 'joinPairs() is not joining the bigrams correctly'###############################################################        if __name__ == "__main__":    main()